# JavaScript 基础面试题
## 1. const申明的变量修改问题
为什么在执行**语句1**的时候，不会报错正常执行；但是**语句2**会报错？
```javascript
// 定义一个变量
const student = { name: '' }

// 在上面这段话的执行中，首先是创建了一个对象，然后将对象存储在堆内存中，
// 并将堆内存中的地址（堆地址）赋值给变量student

// ---------------------
// 语句1
// 执行语句1的时候，首先根据student可以找到堆地址，接着找到目标对象{ name: '' }
// 接着我们尝试去修改目标对象的属性值，这是可行的，对于student常量来说，本身指向的堆地址并未改变
student.name = '张三'

// ---------------------
// 语句2
// 而在执行语句2的时候，我们尝试去修改student变量指向的堆地址，这是不可行的，因为student是一个常量，不能被重新赋值
student = { name: '李四' }
```
## 2. 变量提升（Hoisting）
“变量提升”（Hoisting）是一个重要的概念，它描述了**变量和函数声明**在编译阶段被“移动”到<u>其作用域顶部</u>的行为。
一般情况下（绝大多数情况下）我们开发都遵循先申明后使用的顺序，例如你需要先申明a变量，然后再使用a变量。
但是在JavaScript中，变量和函数的声明会被提升到其作用域的顶部，这就意味着你可以在声明之前就使用变量和函数。
```javascript
// 变量提升
console.log(a); // 输出: undefined
var a = 10;
console.log(a); // 输出: 10

// 实际执行顺序相当于：
// var a;        // 声明提升
// console.log(a); // undefined
// a = 10;       // 赋值在原位置
// console.log(a);
```
核心要点：
- 提升申明：提升的是变量和函数的声明（即上面的var a），而不是赋值（即上面的a = 10）。
- 作用域隔离：变量提升只发生在**当前作用域**，不会影响到其他作用域。

那么此时会有集帅问到：let 和 const 也存在变量提升吗？答案是**肯定**的。