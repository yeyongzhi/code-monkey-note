# 浏览器的工作原理
截至目前，用户常用的浏览器主要有：

- **windows**: Chrome、Edge、火狐Firefox
- **macOS**：safari
## 导航
浏览器最核心、基本的功能就是**访问网页资源。访问网页资源的方式有许多种，其中包含：

- 点击链接...
- 提交表单...
- 直接在地址栏输入网址：`www.baidu.com`访问
- ...

### 第一步：DNS查询（解析IP地址）
每一个网页由静态资源构成（html、css、js和其他类型的文件）。访问网页的过程就是发送给服务器一个请求，服务器将请求对应的网页的静态资源返回到客户端，客户端获取后进行渲染，看到了我们的页面。

但是，我们所熟知的网址（www.baidu.com等等），对于我们都很明确的知道这对应的是百度搜索引擎的网页，但是对计算机来说，它们**不识别域名**，而是识别IP地址。每一个域名对应着**一个唯一的互联网IP地址**。例如假设百度对应的IP地址为**1.2.3.4**，那么计算机就需要知道这个信息。

这一步就被称为**DNS查询（解析IP地址）**，用下图即可概括：

![DNS发起查询请求](./images/DNS1.png)

![DNS得到响应结果](./images/DNS2.png)

> DNS服务器告诉你某个域名对应的IP地址后，这个映射关系会被缓存一段时间。当我们下次访问同样的地址（例如www.baidu.com）的时候，就可以避免再重复DNS查询这一步骤，会加快我们的访问速度。
DNS解析记录会被**计算机、浏览器**等存储在设备当中（注册表等等...）。同时，DNS缓存的时间也不是固定的，根据**DNS服务器、操作系统或者浏览器**等各不相同。一般情况下为24小时左右。

### 第二步：TCP握手（三次查询）
在完成第一步DNS解析后，浏览器就知道了目标网页的IP地址。接下去就是准备进行通信，传输数据了。
TCP的三次握手可以概括为：

1. SYN
2. SYN-ACK
3. ACK

![第一次握手：SYN](./images/DNS1.png)

![第二次握手：SYN-ACK](./images/DNS2.png)

![第三次握手：ACK](./images/DNS1.png)

> **第一次握手：**
发送的**数据包（SYN包）**中的SYN位为1，表示第一次握手的状态。同时携带一个序列号*seq=x*，x是一个随机产生的数值。发送之后此时客户端会进入**SYN_SEND**的状态。等待着服务器的响应
**第二次握手：**
**服务端发送SYN+ACK包**。这个数据包中包含什么数据呢？服务器的一个序列号*seq=y*，同时对客户端的序列号进行了确认（返回*ack=x+1*）。这里的*+1*还表示服务端期望收到的下一个数据包的seq序列号。返回响应后，服务端进入SYN_REVE状态。
**第三次握手：**
客户端接收到服务端发送的SYN+ACK包后，会再次**向服务端发送一个ACK包**，作为一次**最终确认**。这个ack包的序列号即为第二步的*ack=x+1*。此时，客户端进入ESTABLISHED状态，TCP连接建立完成。

上面详细的介绍了三次握手中的数据包含义，序列号等信息，便于我们更加好理解这三次握手对应的的代号（SYN、SYN-ACK、ACK）

### 第三步：TLS协商（Https）
对于通过 HTTPS 建立的安全连接，需要进行另一次握手。**这种握手（TLS协商）**决定了哪个密码将被用于加密通信，验证服务器，并在开始实际的数据传输之前建立一个安全的连接。

> 通过Https建立的链接相对安全性更高，因此需要进行另一次的握手。

![另一次握手：TLS握手](./images/TLS.png)

在这一步骤中，客户端和服务端之间还交换了一些信息，其过程大致如下：

1. **客户端`hello`**：客户端向服务端发送一条消息，包括TLS版本和支持的密码套件（一串数组），以及一串随机字节称为**客户端随机数**。——总共发送三部分信息。
2. **服务端heelo、证书**：服务端返回一条信息，其中包括服务端的TLS证书版本、服务端选择的密码套件和**服务端随机数**。
3. **服务端发送自己的证书**：为了让客户端验证自己的身份，服务端还把自己的证书给发送了过去，证书包含了服务端的公钥。
4. **客户端验证服务器证书**：客户端验证服务端发来的证书（校验证书是否过期、是否有效...），验证通过后回根据服务端的公钥等秘钥生成一个*预主秘钥*。接着把这个*预主秘钥*发送回服务端。
5. 至此为止，客户端服务端均通过信息交换获取到了**客户端随机数**、**服务端随机数**以及**预主秘钥**。根据这三个信息来生成最终的**会话秘钥**。
6. 客户端此时会发送一个消息（Change Cipher Spec）、Finished消息通知服务端：后续我们之间的通信将采用**确定好的密码套件**、**会话秘钥**来进行加密通信。同时验证双方的加密，解密功能都正常OK。TLS握手正式结束。

紧接着双方就可以收发加密的https的请求和响应了。

## 获取数据
### HTTP 请求
在我们建立好TCP握手（或者TLS协商之后），我们就可以准备开始进行通信了。
首先，客户端会发送一个**HTTP GET**请求，请求页面的HTML文件。这一步使用的是**HTTP协议**。

![HTTP请求网页文件](./images/HTTP.png)

统一资源标识符（uniform resource identifier）的缩写是URI，用于识别互联网上的抽象或物理资源（例如网站或电子邮件等资源地址），也就是代表了HTTP 请求的目标。
一个URI通常是由以下几部分组成的：
某些情况下，也会被称为统一资源定位符（Uniform Resource Locator‌）：URL

1. 协议：访问资源所使用的协议，如`http`或`https`
2. 域名：标识服务器所在的地址（也就是IP地址）
3. 端口号：标识服务器上的端口号。默认情况下，HTTP使用80端口、HTTPS使用443端口
4. 路径：指定资源在服务器上的具体路径。
5. 查询参数：键值对的形式拼接在路径的后面，以?开始，通常用于GET请求。
6. 片段标识符：用于指定资源中的某个片段，不会被发送到服务器，例如#fragment

HTTP 请求头

是客户端发送给服务端的请求中的头部字段，包含了一些请求相关的信息。

![HTTP请求头](./images/HTTP_HEADER.png)

### HTTP 响应
一旦服务端接收到客户端发来的HTTP 请求的时候，服务端会对其进行处理并返回一个HTTP 响应。
其中包含了<u>响应头信息</u>、和<u>响应本身的内容</u>。

![HTTP响应头](./images/HTTP_HEADER2.png)

状态码：代表HTTP响应的状态值，一般有**200、400、500**等。其中200表示请求是成功的。‘

一般初始请求的响应，只有HTML被请求并从服务端当中接收到客户端。这个初始请求的响应包含收到的第一个字节的数据。第一个字节的数据（TTFB）是指用户从提出请求（在地址栏输入网站地址访问） 到 收到第一个HTML数据包的时间。

### TCP慢启动和拥塞算法
## HTML解析
HTML的解析是指将程序分析并转换为运行时环境可以执行的内部格式。
这一步由**浏览器引擎**去完成，它是每个浏览器的核心组件（注意这里不是js V8 引擎）。
目前常用的浏览器引擎有以下几种：

1. **Blink**
由Google开发，基于Webkit引擎，具有高性能和快速渲染的特点，广泛应用于众多浏览器中。
例如：Chrome、Edge、国内主流的一些浏览器等等

2. **WebKit**
由KDE项目开发，是一个开源的浏览器引擎，广泛应用于苹果的Safari浏览器，具有良好的标准支持和跨平台特性。
例如：Safari

3. **Gecko**
由Mozilla基金会开发，也是一个开源的渲染引擎，具有良好的跨平台支持和对网页标准的高兼容性。
例如：FireFox

解析过程可以分为 **加载与初始化**、**词法分析** 和 **构造树（DOM树）** 这些步骤

### 1.加载与初始化
浏览器通过HTTP请求获取到HTML文档，开始逐行读取内容。现代浏览器都采用**流式解析（即为边下载边解析）**，而并不是等待整个文档下载完成。注意这里接收到的HTML数据属于**字节流数据**。

例如假设浏览器初始接收到的第一个HTML文档如下所示：
```html
<html>
  <body>
    <div>1</div>
    <div>test</div>
  </body>
</html>
```

### 2.词法分析（标记化Token）——工具：分词器
将HTML代码分解成一个个有具体意义的标记，如标签名（包含开始标签、结束标签）、属性名、属性值，文本内容等。例如对于`<a href="https://example.com">Example</a>`，词法分析会将其分解为
- a：标签名
- href：属性名
- https://example.com：属性值
- Example：文本内容

词法分析这一步骤相当于就是逐行读取，并把HTML内容分解成一系列的Token。这其实相当于<u>你把一篇英文文章拆解为一个个的英语单词</u>，并标记其含义。

### 3.语法分析（构造DOM树）
在第二步的词法分析中，会将分解得到的Token按顺序、结构压入一个**Token栈**。这个栈用于构造DOM树，具体的流程就是**压入Token栈——弹出Token并生成节点——塞入DOM树**。

以上面的HTML片段为例，经过第二步词法分析后得到的一连串Token（注意**这不是Token栈**）如下：

![Token栈](./images/Token.png)

> 补充说明一下，在HTML解析器开始工作的时候，它会自动创建一个doucument结构，同时
创建一个表示document StartTag的Token放入上面的Token栈。

也就是说，初始状态不是全空的，而是如下所示：

![HTML解析器开始工作时](./images/DOMTree1.png)

根据上面的**这串Token栈**，我们详细解读一下DOM树的构建过程。这里会有一个规则清单：

- **规则1**：如果压入到栈中的是StartTag（开始标签），HTML解析器就为这个Token创建一个DOM节点，然后将这个节点插入到DOM树中。具体插入到哪个位置呢？这个节点的父节点就是在栈中相邻的那个Token对应的节点。
- **规则2**：如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，**文本 Token 是不需要压入到栈中**，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。
- **规则3**：如果分词器解析出来的是 EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就**将 StartTag div 从栈中弹出**，表示该 div 元素解析完成。

1. 首先第一位是StartTag（html），属于<u>开始标签</u>，我们直接放入Token栈。符合规则1，执行相应的操作（见上）。创建一个HTML节点，并插入到Document中。得到：

![完成第一步解析](./images/DOMTree2.png)

2. 接着第二位是StartTag（body），也属于<u>开始标签</u>，和上一步一样。不多赘述了。

3. 第三位是StartTag（div），也属于<u>开始标签</u>，和上一步一样。不多赘述了。到此为止，我们会得到：

![完成第三步解析](./images/DOMTree3.png)

4. 到了第四位，有一些特殊。是一个文本：1。此时我们执行规则2，会得到：

![完成第四步解析](./images/DOMTree4.png)

5. 到了第五位，我们会解析到第一个EndTag（div）。此时我们执行规则3，会得到：

![完成第五步解析](./images/DOMTree5.png)

6. 如此往复直到遍历完成所有的Token，最终我们会得到如下图所示。此时DOM树已经完整生成。

![最终结果](./images/DOMTree6.png)

> 上面演示的仅仅是一个最简单、最基础的HTML结构生成DOM树的过程。实际应用中，除了最基本的HTML结构还包含CSS和Javascript，又包含其它一些媒体文件（图片、视频、音频等等），所以处理过程会远比上面演示的更复杂。我们首先要理解上面演示的这个最基本的原理即可。

那么问题来了，当我们碰到一些复杂的HTML结构，其执行过程是怎么样的呢？
这就是**外部资源处理与阻塞机制**

#### 外部资源处理与阻塞机制
```html
<html>
  <body>
    <div>1</div>
    <script>
      let div1 = document.getElementsByTagName('div')[0]
      div1.innerText = 'time.geekbang'
    </script>
    <div>test</div>
  </body>
</html>
```

比如上面这段代码，前面的过程都一样。但是当解析到`script`标签的时候，HTML解析器判断这是一段可执行脚本，此时就会暂停DOM的解析构建过程。因为脚本中可能会对DOM结构进行修改。<u>js是单线程语言</u>。

![执行到script标签前的DOM树结构](./images/DOMTree7.png)

此时，<u>HTML解析器暂停工作，Javascript引擎介入工作</u>，并**执行script标签中的这段脚本代码**。
这段脚本代码修改了第一个div标签中的内容（从原本的1改为了'time.geekbang'），那么此时DOM树结构为：
![执行完script标签后的DOM树结构](./images/DOMTree8.png)

Javascript脚本执行完毕后，HTML解析器继续工作，将剩余的HTML文档继续解析。直到生成最终的DOM树。

除了上面这种内嵌的js脚本代码会被识别并执行以外，还有一种常见的方式就是外部引入的js脚本文件。比如：

```js
let div1 = document.getElementsByTagName('div')[0]
div1.innerText = 'time.geekbang'
```

```html
<html>
  <body>
    <div>1</div>
    <script type="text/javascript" src="foo.js"></script>
    <div>test</div>
  </body>
</html>
```

针对上面这种外部引入的js脚本代码的情况，我们再来梳理一遍整个过程：
前面步骤都是一致的，解析到script标签的时候，HTML解析器会暂停DOM的解析构建过程。但是由于这里的js代码是外部引入的，需要先下载js文件。同时，js下载过程会阻塞DOM树的构建过程，通常js的下载过程又是非常耗时的（因为一般引入的外部js资源文件都会比较大，而且还会受到网络环境的影响）。

不过**浏览器**做了一些优化，其中一个就是**预解析**。也就是当浏览器接收到HTML文档的字节流数据之后，会提前先扫描一遍整个文档，分析HTML中的外部资源（js、css、图片等等）。并**提前下载**好这些资源。

从资源本身角度来看，我们也有一些对应的方案去优化，比如使用<u>CDN来加速js文件的加载</u>，尽可能的<u>压缩js文件的体积</u>等等。另外，如果js代码中没有操作DOM的代码，可以把该js文件设置为**异步加载**。异步加载的意思就是<u>DOM树构建的过程中，js文件在另一边下载，两者互不影响</u>。

```javascript
 <script async type="text/javascript" src='foo.js'></script>
 <script defer type="text/javascript" src='foo.js'></script>
```

- async: 异步加载的js代码在加载完成后，<u>会立即执行</u>。
- defer： 异步加载的js代码在加载完成后，<u>不会立即执行</u>。需要在**DOMContentLoaded**事件之前执行。

OK ，到这里我们已经把HTML解析的过程基本讲完了。

## CSS解析
上面讲的是HTML的解析过程，完成之后，我们会得到一个<u>DOM树</u>。接下去的CSS解析的过程，完成之后我们会得到一个<u>CSSOM树</u>。两者结构类似，有了这两个东西我们才可以构建我们的<u>渲染树</u>。

还记得前面说到的浏览器针对外部资源的优化吗？有一种叫做预加载的方式。在HTML中，css的表现形式主要有以下三种：

1. **内嵌样式**：将css代码直接写在HTML的style标签中。
2. **外联样式**：将css代码写在一个单独的css文件中，并通过link标签引入（这种方式会可能通过预加载的行为被优化）。
3. **行内样式**：将css代码写在HTML标签的style属性中。

### 生成Token
在我们读取CSS文件后，会将其转化为字符格式。然后经过词法分析（和构建DOM树的那一步骤相似），将解析得到的内容转化为一个一个的**Token标签**。每个Token中可能包含的内容有：

- 标识符：例如选择器的名称（body,h1,.container），属性名（color,font-size）。
- 关键字：例如font-weight的值（bold,normal）。
- 字符串：例如属性值（'red',"Helvetica"）。
- 数字：例如font-size的值（16px,1.5em）。
- URL：例如背景图片的路径（url("image.jpg")）。
- ...

接着CSS解析器会根据这些零散的Token标签构建出一个个的**CSS规则节点**。这就好比是DOM树的最小单位：DOM节点。CSS规则节点是CSSOM树的<u>基本组成部分</u>。

CSS规则节点主要包含以下几类：

1. 普通规则节点（Regular Rule Nodes）
2. 媒体查询规则节点（Media Query Rule Nodes）
3. 支持条件规则节点（Supports Rule Nodes）
4. 文档规则节点（Document Rule Nodes）
5. 页面规则节点（Page Rule Nodes）
6. 字体规则节点（Font Rule Nodes）
7. 键帧规则节点（Keyframes Rule Nodes）
8. 命名空间规则节点（Namespace Rule Nodes）

其实最常见、最常用的就是<u>普通规则节点</u>。CSS普通规则节点主要是由两部分构成：**选择器和声明块**。来详细看一下普通规则节点的结构：

```css
body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f4;
}
```
对于上面这段CSS代码，生成得到的CSS规则节点如下：

![CSS普通规则节点](./images/CSSOMTree1.png)

我们再举一个媒体查询规则节点的例子：

```css
@media (min-width: 600px) {
    body {
        font-family: Arial, sans-serif;
        background-color: #f4f4f4;
    }
}
```

![CSS媒体查询规则节点](./images/CSSOMTree2.png)

> 在上面这个图中，我们可以很清晰的看到规则节点之间的"父子"关系。图中媒体查询规则节点是父节点，普通规则节点是子节点。